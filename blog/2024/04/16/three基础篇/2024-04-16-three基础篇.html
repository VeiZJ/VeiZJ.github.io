<hr>
<h2 id="title-three基础篇date-2024-04-16-16-01-16tags-ThreeJScategories-ThreeJs"><a href="#title-three基础篇date-2024-04-16-16-01-16tags-ThreeJScategories-ThreeJs" class="headerlink" title="title: three基础篇date: 2024-04-16 16:01:16tags: ThreeJScategories: ThreeJs"></a>title: three基础篇<br>date: 2024-04-16 16:01:16<br>tags: ThreeJS<br>categories: ThreeJs</h2><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><h4 id="基类：Material"><a href="#基类：Material" class="headerlink" title="基类：Material"></a>基类：Material</h4><p>定义：材质描述了对象objects的外光，它们的定义方式与渲染器无关，如果使用不同的渲染器，则不必重写材质。</p>
<p><img src="/./1702368339909.png" alt="1702368339909"></p>
<p><img src="/./1702368442450.png" alt="1702368442450"></p>
<p>整体上来看，就是渲染表现能力越强，占用的计算机硬件资源更多。</p>
<ul>
<li>占用渲染资源 MeshBasicMaterial &lt; MeshLambertMaterial &lt; MeshPhongMaterial &lt; MeshStandardMaterial &lt; MeshPhysicalMaterial</li>
<li>渲染表现能力 MeshBasicMaterial &lt; MeshLambertMaterial &lt; MeshPhongMaterial &lt; MeshStandardMaterial &lt; MeshPhysicalMaterial</li>
</ul>
<h5 id="材质或集合体共享"><a href="#材质或集合体共享" class="headerlink" title="材质或集合体共享"></a>材质或集合体共享</h5><p>我们可以直接访问并修改物体的材质对象，因为材质事共享的如果对其进行修改该用到该材质的物体都会发生改变</p>
<p>我们同时也可以直接访问并修改物体的集合体对象，若有其他物体也是用到这个集合体 修改后也会造成影响。</p>
<p><img src="/./1702370190692.png" alt="1702370190692"></p>
<h5 id="三维变量的克隆和复制方法"><a href="#三维变量的克隆和复制方法" class="headerlink" title="三维变量的克隆和复制方法"></a>三维变量的克隆和复制方法</h5><p>let v1 &#x3D; new three.Vector(.&#x2F;1,2,3)</p>
<p>letv2 &#x3D; v1.clone() &#x2F;&#x2F;此时会克隆一个与v1一样属性与值得对象</p>
<p>let v3 &#x3D;  {}</p>
<p>v3.copy(v1)可将v1得值赋值给v3 </p>
<p>若是物体得克隆 他的材质与集合体不单独进行克隆得话 那么材质和集合体还是存在共享问题</p>
<p><img src="/./1702368996979.png" alt="1702368996979"></p>
<h4 id="顶点："><a href="#顶点：" class="headerlink" title="顶点："></a>顶点：</h4><p>顶点的每个坐标对应一个顶点法线 ，法线关系光照后阴影的角度。</p>
<p>物体的属性有一些列的属性：position,rotation,scalr等属性 还有相关的方法，其都会继承父级构造函数的属性和方法</p>
<p>向量：normalize 将向量转为单位向量 长度为1</p>
<p><img src="/./1702368060275.png" alt="1702368060275"></p>
<h3 id="组对象group"><a href="#组对象group" class="headerlink" title="组对象group"></a>组对象group</h3><p><img src="/./1702435513665.png" alt="1702435513665"></p>
<p>子对象：group得children属性下可以查看到这个组对象下面得所有子对象。</p>
<p>子对象任何变化始终都是根据着父节点进行的。我们也可以直接使用Object3D创建一个节点对象，也可以给网格添加子对象。</p>
<p>通过设置name 可以给相应的物体设置指定的名字。</p>
<p>Object3D.traverse遍历所有的子节点</p>
<p>Object3D.getObjectByName() 获取指定名称的节点</p>
<p>本地坐标：当前物体的的坐标就是position的位置</p>
<p>Object3D.postion 表示物体的局部位置</p>
<p>世界坐标：本地坐标加上所有上级的坐标累加坐标，是为子集物体始终是相对于父级物体进行偏移的 </p>
<p>Object3D.getWordPosition（v3）:将当前物体的三维坐标存在一个三维向量中，可以获取当这个物体的世界坐标</p>
<p>当我们通过translate修改了集合体顶点坐标的时候，该物体的局部坐标系并没有发生改变，所有我们对这个物体（object3d）的一些列操作（如rotate）这个物体模型会相对于坐标原点进行</p>
<p>物体隐藏visible：物体object3d 隐藏或显示一个模型。 隐藏父级物体 他的子集物体也会被隐藏</p>
<p> 材质隐藏visible：材质materail 通过该属性可以控制是否隐藏该材质对应的模型对象。 相同材质的隐藏的话 所有使用到此材质的物体的模型都会被隐藏</p>
<p>object3d.remove:  scene , mesh ,都有删除这个方法 与add添加模型对立，可以删除他的子代模型 如“senec.remove(light)删除环境光，因为光照也是通过add添加的 ，场景模型多的话可以遍历子代模型条件删除一些模型。在进行删除尝试中发现了一个微妙的问题，就是在遍历traverse中不建议直接删除当前的属性。会出现一些奇怪的问题</p>
<p><img src="/./1702544424552.png" alt="1702544424552"></p>
<h4 id="模型数的遍历"><a href="#模型数的遍历" class="headerlink" title="模型数的遍历"></a>模型数的遍历</h4><p>object3D.traverse() 遍历了下面的所有子子节点。</p>
<p>object3D.getObjectByName() 根据Object.name来查找对应的名字的模型</p>
<p>object3D.visible  控制模型的显示与隐藏</p>
<h4 id="模型-gltf"><a href="#模型-gltf" class="headerlink" title="模型:gltf"></a>模型:gltf</h4><p>包含内容：几乎包含了该模型的所有数据 模型的层级关系,rgb材质，纹理材质,骨骼动画，变形动画…</p>
<p>格式信息：</p>
<pre><code class="json">{
  &quot;asset&quot;: {
    &quot;version&quot;: &quot;2.0&quot;,
  },
...
// 模型材质信息
  &quot;materials&quot;: [
    {
      &quot;pbrMetallicRoughness&quot;: {//PBR材质
        &quot;baseColorFactor&quot;: [1,1,0,1],
        &quot;metallicFactor&quot;: 0.5,//金属度
        &quot;roughnessFactor&quot;: 1//粗糙度
      }
    }
  ],
  // 网格模型数据
  &quot;meshes&quot;: ...
  // 纹理贴图
  &quot;images&quot;: [
        {
            // uri指向外部图像文件
            &quot;uri&quot;: &quot;贴图名称.png&quot;//图像数据也可以直接存储在.gltf文件中
        }
   ],
     &quot;buffers&quot;: [
    // 一个buffer对应一个二进制数据块，可能是顶点位置 、顶点索引等数据
    {
      &quot;byteLength&quot;: 840,
     //这里面的顶点数据，也快成单独以.bin文件的形式存在   
      &quot;uri&quot;: &quot;data:application/octet-stream;base64,AAAAPwAAAD8AAAA/AAAAPwAAAD8AAAC/.......
    }
  ],
}
</code></pre>
<p>gltf格式文件不一定就是以扩展名.gltf结尾，.glb就是gltf格式的二进制文件。比如你可以把.gltf模型和贴图信息全部合成得到一个.glb文件中，.glb文件相对.gltf文件体积更小，网络传输自然更快。</p>
<p><strong>load（’模型地址’，加载成功后的函数，加载时的相关信息）</strong>:我们可以在加载函数中再次处理这个模型，如修改模型的相关属性，可以通过第三个参数来设置相关进度条…</p>
<p><strong>查询模型节点</strong>：getObjectName() 根据模型的name属性来查询谋和模型对象</p>
<p><strong>遍历模型<code>traverse</code></strong>:</p>
<p><strong>查看gltf的默认材质</strong>：</p>
<p>材质相同问题：模型材质共享的问题判断材质的name 是否相同，</p>
<p>解决方案：1,三维建模软件中设置,需要代码改变材质不要共享，要独享材质。2,代码批量更改，克隆材质对象，重新赋值给mesh的材质属性.</p>
<pre><code class="js">gltf.scne.getObjectByName(&#39;汽车&#39;).traverse(function(item){
    if(item.isMesh){
        item.material = obj.material.clone()
    }
})
</code></pre>
<h4 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h4><p>如果没有特殊的需求，一般为了正常渲染，避免色差，three.js中贴图的颜色空间编码属性encoding要与webGL渲染器的outputEncoding属性（最新版本中属性名已改为 outputColorSpace ）保持一致。</p>
<p>纹理对象的encoding有多个属性：THREE.LinearEncoding（线性颜色空间：3000 ）,THREE.sRGBEncoding （sRGB颜色空间：3001）</p>
<p>如果webGL的渲染器的色彩空间手动设置了后面的添加的纹理也需要设置成相关的色彩空间（最新版中纹理对象的色彩空间属性名已由encoding改为colorSpace）</p>
<p>给gltf模型更换颜色贴图：TextureLoader()加载新的模型数据 如果直接给gltf的模型材质map设置新的纹理会出现错位的情况，这和贴图的texture的翻转flipY属性有关。</p>
<p>纹理对象的flipY默认值为trun ,gltf的贴图flipY默认值为false,跟换模型的贴图时需要设置为false.</p>
<p>纹理的列阵wrapS wrapT 分别是在UV轴上的如何进行包裹。repeat在uv轴上重复的数量</p>
<p>环境贴图：</p>
<p>立方体纹理加载器cubetextureLoader </p>
<p>这个加载器加载六个图片作为空间的上下左右前后，这个用来加载环境贴图，</p>
<pre><code class="js">// 加载环境贴图
// 加载周围环境6个方向贴图
// 上下左右前后6张贴图构成一个立方体空间
// &#39;px.jpg&#39;, &#39;nx.jpg&#39;：x轴正方向、负方向贴图  p:正positive  n:负negative
// &#39;py.jpg&#39;, &#39;ny.jpg&#39;：y轴贴图
// &#39;pz.jpg&#39;, &#39;nz.jpg&#39;：z轴贴图
const textureCube = new THREE.CubeTextureLoader()
    .setPath(&#39;./环境贴图/环境贴图0/&#39;)
    .load([&#39;px.jpg&#39;, &#39;nx.jpg&#39;, &#39;py.jpg&#39;, &#39;ny.jpg&#39;, &#39;pz.jpg&#39;, &#39;nz.jpg&#39;]);
    // CubeTexture表示立方体纹理对象，父类是纹理对象Texture 
</code></pre>
<p>材质MeshStandardMaterial的envMap环境贴图属性，通过pbr材质的贴图属性反射周围的景物。</p>
<p>envMapIntensity属性控制了反光率 <code>roughness</code>：控制粗糙度</p>
<p>环境贴图的色彩空间编码应该与渲染器的保持一致</p>
<p><strong>&#x2F;&#x2F;pbr材质的相关属性：</strong></p>
<p>clearcoat：可以给物体表面设置一层透明膜，就像一层透明的漆，范围在0-1.</p>
<p>clearcoatRoughness：0-1 ；清漆层的粗糙层度。</p>
<p>metalness: 0.9,&#x2F;&#x2F;车外壳金属度<br>roughness: 0.5,&#x2F;&#x2F;车外壳粗糙度</p>
<p>transmission 玻璃透明度</p>
<p>Ior:折光率</p>
<h5 id="场景的背景："><a href="#场景的背景：" class="headerlink" title="场景的背景："></a>场景的背景：</h5><p> 透明度：new Three.WebGLRenderer({alpha：true})或 render.setColorAlpha:0-1</p>
<p>背景色：render.setClearColor(颜色,透明度)</p>
<h6 id="导出图片："><a href="#导出图片：" class="headerlink" title="导出图片："></a>导出图片：</h6><p>1.创建a标签 </p>
<p>2.设置a标签的herf的 为场景的canvas元素，可以通过render.domElement获取</p>
<p>3.渲染器设置preserveDrawingBuffer为true ，开启缓存。</p>
<p>4.通过canvas的toDataURL(‘image&#x2F;png’)获取话不上的像素信息，将以png的格式保存。</p>
<h6 id="mesh重叠时候会出现闪缩的情况叫做深度冲突（z-fighting）"><a href="#mesh重叠时候会出现闪缩的情况叫做深度冲突（z-fighting）" class="headerlink" title="mesh重叠时候会出现闪缩的情况叫做深度冲突（z-fighting）"></a>mesh重叠时候会出现闪缩的情况叫做深度冲突（z-fighting）</h6><h5 id="自定义划线：顶点数据来画"><a href="#自定义划线：顶点数据来画" class="headerlink" title="自定义划线：顶点数据来画"></a>自定义划线：顶点数据来画</h5><p>几何体setFromPoints（v3）将v3顶点数据设为几何体的attribute.position的顶点位置属性。除了可以是三维向量数组还可以是二位向量数组。</p>
<h5 id="曲线：基类cuver"><a href="#曲线：基类cuver" class="headerlink" title="曲线：基类cuver"></a>曲线：基类cuver</h5><p><img src="/./1712822846881.png" alt="1712822846881"></p>
<h3 id="管道几何体"><a href="#管道几何体" class="headerlink" title="管道几何体"></a>管道几何体</h3><pre><code>TubeGeometry(path, tubularSegments, radius, radiusSegments, closed)
</code></pre>
<h3 id="旋转成型几何体"><a href="#旋转成型几何体" class="headerlink" title="旋转成型几何体"></a>旋转成型几何体</h3><p><strong>LatheGeometry</strong>：通过一个圆形轮廓坐标点 旋转得到一个几何体曲面</p>
<pre><code>LatheGeometry(points, segments, phiStart, phiLength)
points为一个二维矢量组成的一个线段 segments为细分数， phiStart开始角度 phiLength旋转的角度默认值2π
</code></pre>
<h3 id="形状几何体"><a href="#形状几何体" class="headerlink" title="形状几何体"></a>形状几何体</h3><p><strong>ShapeGeometry：</strong>通过一个集合的轮廓得到一个多边形几何体平面。</p>
<p>先通过 Shape 将这些点生成一个二维平面，shape([二维矢量点数组…])</p>
<p> 用ShapeGeometry 将这个二位平面装维平面几何体  ShapeGeometry （shape）</p>
<h3 id="多边形轮廓shape-重点"><a href="#多边形轮廓shape-重点" class="headerlink" title="多边形轮廓shape(重点)"></a>多边形轮廓shape(重点)</h3><p>使用一些列路径传入shape生成一个多边形的形状，它可以和<strong>ExtrudeGeometry</strong>、<strong>ShapeGeometry</strong>一起使用，获取点，或者获取三角，也可以获得一个该形状的几何体，非常Nice.</p>
<pre><code>父类为Path，所以也是继承了父类的相关方法与属性，如画线，画圆，画椭圆，等等获取当前点等属性。
传入点组成opints，可构造一个自定任意形状的多边形
</code></pre>
<p><img src="/./1713148838218.png" alt="1713148838218"></p>
<h6 id="若线与圆弧组合的时候，第一次的结束点自动衍生至第二个圆弧的起点。当前一次线画完时会采取以当前的currentPoint为中心点。"><a href="#若线与圆弧组合的时候，第一次的结束点自动衍生至第二个圆弧的起点。当前一次线画完时会采取以当前的currentPoint为中心点。" class="headerlink" title="若线与圆弧组合的时候，第一次的结束点自动衍生至第二个圆弧的起点。当前一次线画完时会采取以当前的currentPoint为中心点。"></a>若线与圆弧组合的时候，第一次的结束点自动衍生至第二个圆弧的起点。当前一次线画完时会采取以当前的currentPoint为中心点。</h6><h6 id="shape的线与圆共同使用的时候，他们的起点会相连接"><a href="#shape的线与圆共同使用的时候，他们的起点会相连接" class="headerlink" title="shape的线与圆共同使用的时候，他们的起点会相连接"></a>shape的线与圆共同使用的时候，他们的起点会相连接</h6><p><img src="/./1713149897591.png" alt="1713149897591"></p>
<h6 id="内孔：holes"><a href="#内孔：holes" class="headerlink" title="内孔：holes"></a>内孔：holes</h6><p>在创建的shape内挖出对应的孔洞，这些孔洞的坐标位置相对原点。</p>
<p><img src="/./1713153199017.png" alt="1713153199017"></p>
<h3 id="边缘几何体"><a href="#边缘几何体" class="headerlink" title="边缘几何体"></a>边缘几何体</h3><p><strong>EdgesGeometry</strong>：给指定几何体添加外边框线查看其边缘。</p>
<pre><code class="js">    // 集合体的边界线EdgesGeometry
    const geometryModle = new THREE.CylinderGeometry(2,2,32)
    const materialModle = new THREE.MeshLambertMaterial({
        color: 0x004444,
        transparent:true,
        opacity:0.5,
    })
    const mesh2 = new THREE.Mesh(geometryModle,materialModle)
        scene.add(mesh2)
    const edgesGeometry = new THREE.EdgesGeometry(geometryModle,30)//第二次参数时发现角度大于	多少时才会渲染
    const edgesMaterial = new THREE.LineBasicMaterial({
        color: 0x00ffff,
    })
    const lineModle = new THREE.LineSegments(edgesGeometry,edgesMaterial)
        scene.add(lineModle)
    // 同理相关模型也可以在加载完成后也可以添加边缘线。
modelLoader.load(&#39;./bwm/scene.gltf&#39;,(gltf)=&gt;{
        gltf.scene.position.set(5,0,5)
        gltf.scene.traverse((item)=&gt;{
            if(item.isMesh){
                item.material = new THREE.MeshLambertMaterial({//设置新的材质属性
                     color: 0x004444,
                     transparent: true,
                     opacity: 0.5,
                 })
                 const itemEdge = new THREE.EdgesGeometry(item.geometry)//创建外框线
                 const itemLineMaterial = new THREE.LineBasicMaterial({//线性材质
                     color: 0x00ffff,
                 })
                 const itemLine = new THREE.Line(itemEdge,itemLineMaterial)
                 item.add(itemLine)
            }
        })
           scene.add(gltf.scene)//模型添加到场景中
</code></pre>
<h3 id="拉伸几何体"><a href="#拉伸几何体" class="headerlink" title="拉伸几何体"></a>拉伸几何体</h3><p>**ExtrudeGeometry :**也是通过一个平面坐标拉成一个几何体，</p>
<p>参数：</p>
<pre><code class="javascript">          depth: 20,
        bevelThickness: 5, //倒角尺寸:拉伸方向
        bevelSize: 5, //倒角尺寸:垂直拉伸方向
        bevelSegments: 20, //倒圆角：倒角细分精度，默认3
        extrudePath:cuverpath//通过一个三维曲线让这个多变对其沿着这个曲线拉伸
        steps:100//沿着路径细分精度，越大越光滑
</code></pre>
<p><img src="/./1712907318826.png" alt="1712907318826"></p>
<h5 id="弯曲水管流动效果："><a href="#弯曲水管流动效果：" class="headerlink" title="弯曲水管流动效果："></a>弯曲水管流动效果：</h5><p>贴图版本：创建一个贴图，然后将贴图设置一个阵列模式。再render函数中给贴图的x轴的点进行+1。</p>
<pre><code class="js">const pointsV = new THREE.CatmullRomCurve3([
        new THREE.Vector3(20,10,5),
        new THREE.Vector3(0,0,0),
        new THREE.Vector3(-20,-15,-50),
    ])
    const pipeBackgroundImage = new THREE.TextureLoader().load(img)
    // pipeBackgroundImage.encoding = THREE.SRGBColorSpace
   // 设置阵列模式
    pipeBackgroundImage.wrapS = THREE.RepeatWrapping;
    pipeBackgroundImage.wrapT = THREE.RepeatWrapping;
    // uv两个方向纹理重复数量
    pipeBackgroundImage.repeat.set(./1,1);//注意选择合适的阵列数量
    pipeBackgroundImage.encoding = THREE.SRGBColorSpace
    console.log(pipeBackgroundImage,&#39;tuoian&#39;);
    const pipeline = new THREE.TubeGeometry(pointsV,65, 2, 25)
    const pipeMaterial = new THREE.MeshPhysicalMaterial({emissive:&#39;#3f7b9d&#39;,side:THREE.DoubleSide,map:pipeBackgroundImage,clearcoat:1})
    const pipeMesh = new THREE.Mesh(pipeline,pipeMaterial)
    scene.add(pipeMesh)
 function animation(){
        pipeBackgroundImage.offset.x += 0.0001; //uv动画
        renderer.render(scene,camera)
        requestAnimationFrame(animation)
}
animation(){
</code></pre>
<h3 id="几何体的顶点属性"><a href="#几何体的顶点属性" class="headerlink" title="几何体的顶点属性"></a>几何体的顶点属性</h3><p>顶点<strong>位置</strong>数据<code>geometry.attributes.position</code></p>
<p>顶点<strong>法向量</strong>数据<code>geometry.attributes.normal</code></p>
<p>顶点<strong>UV</strong>数据<code>geometry.attributes.uv</code></p>
<p>顶点<strong>颜色</strong>数据<code>geometry.attributes.color</code></p>
<p>如何使用顶点颜色: 创建相关几何体时，通过设置起这个几何体顶点数量的颜色。</p>
<p>*若要添加顶点颜色需要在材质中开启vertexColors ，材质的color属性可以不用设置了 </p>
<p>*rgb 范围1-0</p>
<pre><code>const colors = new Float32Array([
     1, 0, 0, //顶点1颜色 
     0, 0, 1, //顶点2颜色
     0, 1, 0, //顶点3颜色
     ])
geotry.attributes.color = new three.BufferAttribute(colors,3) //三个一组

</code></pre>
<p><em>颜色的rgb范围如下图  ↓</em></p>
<p><img src="/./1713170230091.png" alt="1713170230091"></p>
<p>绘制彩色曲线</p>
<pre><code class="js">// 1.创建一个三维贝塞尔曲线或者其他曲线
const peakCover = new three.CubicBezierCurve3(
  new THREE.Vector3(4,4,4),
  new THREE.Vector3(4,5,6),
  new THREE.Vector3(7,6,6),
)

//2.获取这个曲线上的所有点位 .getpoints() 参数将曲线分割为多少个点
const peackPoints = peackCover.getpoints(20)

//3.设置这些点位的颜色
let peackColors = []
for(let i =0;i&lt;peackPoints.length;i++){
    const itemValue = i / peackPoints.length //等到这个点位对应的rgb
    peackColors.push(itemValue,0,1)
}

//4.设置集合体的顶点数据
const peackCoverGeotry = new three.BufferGeometry().setFromPoints(new Float32Array(peackColors),3)

//5.创建曲线材质
const peackCoverMaterial = new three.LineBasicMaterial({
 vertexColors:true,//使用顶点颜色渲染
 // color:&#39;red&#39;
})

//创建线条
const coverLine = new three.Line(peackCoverGeotry,peackCoverMaterial)
scene.add(coverLine)
</code></pre>
<h3 id="Color的使用"><a href="#Color的使用" class="headerlink" title="Color的使用"></a>Color的使用</h3><p>THREE.Color(r,g,b) 当所有参数被定义时，r是红色分量，g是绿色分量，b是蓝色分量。<br>当只有 r 被定义时：</p>
<ul>
<li>它可用一个十六进制 <a href="https://en.wikipedia.org/wiki/Web_colors#Hex_triplet">hexadecimal triplet</a> 值表示颜色（推荐）。</li>
<li>它可以是一个另一个颜色实例。</li>
<li>它可以是另外一个CSS样式。例如：<ul>
<li>‘rgb(250, 0,0)’</li>
<li>‘rgb(.&#x2F;100%,0%,0%)’</li>
<li>‘hsl(0, 100%, 50%)’</li>
<li>‘#ff0000’</li>
<li>‘#f00’</li>
<li>‘red’</li>
</ul>
</li>
</ul>
<pre><code>const color = new THREE.Color(r,g,b)
</code></pre>
<h6 id="color的插值"><a href="#color的插值" class="headerlink" title="color的插值"></a>color的插值</h6><pre><code class="js">//lerpColors
const c1 = new THREE.Color(0xff0000); //红色
const c2 = new THREE.Color(0x0000ff); //蓝色
const c = new THREE.Color();
// 颜色3.lerpColors(颜色1，颜色2，占比) 占比为两种颜色各占多少 但占比为0时到的颜色就是颜色1 占比为1时得到的颜色就是颜色2。 
c = c.lerpColors(c1,c2,占比Value)
// lerp(颜色1,占比value)
c1.lerp(c2,1)// 颜色1.lerp(颜色2,占比) 占比为颜色1与颜色2的占比 占比为0为颜色1， 占比为2时为颜色2

let c3 = c1.clone().lerColor(c1,c2,占比)//这里是先克隆在用插值修改这个颜色

</code></pre>
<p>颜色插值的应用:不用自己用相关逻辑来写颜色的属性数组，</p>
<pre><code>   let peakCoverPoint = peakCover.getPoints(20)//获取曲线上的点
    let colorArr = []
    for(let i=0;i&lt; peakCoverPoint.length ;i++){
        const percent = i / peakCoverPoint.length; //点索引值相对所有点数量的百分比
        //根据顶点位置顺序大小设置颜色渐变
        // 红色分量从0到1变化，蓝色分量从1到0变化
        colorArr.push(percent, 0, 1); //蓝色到红色渐变色
    }
    // 优化↓
    let c1 = new three.Color(0x00ffff)
    let c2 = new three.Color(0xffff00)
    for(let i=0;i&lt; peakCoverPoint.length ;i++){
    const percent = i / peakCoverPoint.length; //点索引值相对所有点数量的百分比
    //根据顶点位置顺序大小设置颜色渐变
    let c = c1.clone(c2,percent)
    colorArr.push(c.r, c.g, c.b); //颜色插值计算
    }
</code></pre>
<h3 id="模型的顶点及数据处理"><a href="#模型的顶点及数据处理" class="headerlink" title="模型的顶点及数据处理"></a>模型的顶点及数据处理</h3><p>引入的模型有些在返回的模型json对象的scne.children[0]中有geometry属性。有的会在其下面继续拓展多个物体。此时我们就需要遍历这个对象，去获取他的顶点数据。</p>
<h6 id="BufferAttribute具有getX-getY-getZ-方法获取x-1维-y-2维-z-3维-指定项的数据"><a href="#BufferAttribute具有getX-getY-getZ-方法获取x-1维-y-2维-z-3维-指定项的数据" class="headerlink" title="BufferAttribute具有getX(), getY() ,getZ() 方法获取x(.&#x2F;1维) y(2维) z(3维) 指定项的数据"></a>BufferAttribute具有getX(), getY() ,getZ() 方法获取x(.&#x2F;1维) y(2维) z(3维) 指定项的数据</h6><pre><code class="js">    //通过顶点数据 来将山体根据高度着色
    modelLoader.load(&#39;shan2.glb&#39;,(gltf)=&gt;{
        gltf.scene.position.set(5,0,5)
        console.log( gltf.scene);
        gltf.scene.scale.set(25,25,25)

        const zArr = [] //顶点数据组
        //遍历所有物体的顶点将塞入zArr
        gltf.scene.traverse(item=&gt;{
            let itemAttributes = item.geometry.attributes//顶点属性
            let itemPosition = item.geometry.attributes.position//顶点位置数据
            //在位置数据中有一个count表示这个物体有多少个顶点
            for(let i = 0;i&lt;itemPosition.length;i++){
                zArr.push(itemPosition.getZ(i))
            }
        })
        zArr.sort()//升序排序
        let minHeight = zArr[0]//山脚高度
        let maxHeight = zArr[zArr.length - 1]//山顶高度
        let height = maxHeight - minHeight //山体的高度
        let minColor = new THREE.Color(0x0000ff)//山脚颜色
        let maxColor = new THREE.Color(0xff0000)//山顶颜色
        //再次根据当前顶点个数进行循环 设置当前的顶点颜色
        gltf.scene.traverse(item=&gt;{
            let itemAttributes = item.geometry.attributes//顶点属性
            let itemPosition = item.geometry.attributes.position//顶点位置数据
            let colorArr = []
             for(let i = 0;i&lt;itemPosition.count;i++){
                let colorVal = (itemPosition.getZ(I) - minHeight) / height
                let c = minColor.clone().lerp(maxColor,colorVal)
                colorArr.push(c.r,c.g,c.b)
            }
            let float32Arr = new three.Float32Array(colorArr)
            itemAttributes.geometry.color = new three.BufferAttribute(float32Arr,3)
            
            item.material = new three.MeshLambertMaterial({
                 vertexColors:true//开启顶点颜色
            })
        })
        
     })

</code></pre>
<p><img src="/./1713253141908.png" alt="1713253141908"></p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h3 id="资源网站"><a href="#资源网站" class="headerlink" title="资源网站"></a>资源网站</h3><ul>
<li><p>3D模型下载：<a href="https://sketchfab.com/">https://sketchfab.com/</a></p>
</li>
<li><p>骨骼自动绑定：<a href="https://www.mixamo.com/">https://www.mixamo.com/</a></p>
</li>
<li><p>360°全景图裁切工具（收费）：<a href="https://www.ptgui.com/download.html?ps=main">https://www.ptgui.com/download.html?ps=main</a></p>
</li>
<li><p>天空盒切割工具：<a href="https://matheowis.github.io/HDRI-to-CubeMap/">https://matheowis.github.io/HDRI-to-CubeMap/</a></p>
</li>
<li><p>超全GSAP动画库：<a href="https://greensock.com/">https://greensock.com/</a></p>
</li>
<li><p>three官方文档：<a href="https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene">https://threejs.org/docs/index.html#manual/zh/introduction/Creating-a-scene</a></p>
</li>
<li><p>在线免费教程：<a href="http://www.webgl3d.cn/Three.js/">http://www.webgl3d.cn/Three.js/</a></p>
</li>
<li><p>cannon 物理引擎：<a href="https://github.com/pmndrs/cannon-es">https://github.com/pmndrs/cannon-es</a></p>
</li>
<li><p>Physijs 物理引擎：<a href="https://github.com/chandlerprall/Physijs">https://github.com/chandlerprall/Physijs</a></p>
</li>
<li><p>tween.js 创建补间动画（控制机械、游戏角色运动）：<a href="https://github.com/tweenjs/tween.js/">https://github.com/tweenjs/tween.js/</a></p>
</li>
<li><p>dat.gui 轻量级控制器：<a href="https://github.com/dataarts/dat.gui">https://github.com/dataarts/dat.gui</a></p>
</li>
<li><p>stats.js 性能监控器（webgl渲染性能）：<a href="https://github.com/mrdoob/stats.js">https://github.com/mrdoob/stats.js</a></p>
</li>
<li><p>3D素材网-1：<a href="https://www.poliigon.com/textures">https://www.poliigon.com/textures</a></p>
</li>
<li><p>3D素材网-2：<a href="https://www.aigei.com/">https://www.aigei.com/</a></p>
</li>
<li><p>3D素材网-3：<a href="https://www.3dsmj.com/">https://www.3dsmj.com/</a></p>
<h5 id="模型网站"><a href="#模型网站" class="headerlink" title="模型网站"></a>模型网站</h5></li>
<li><p>1，Turbosquid</p>
</li>
<li><p>2，Free 3D</p>
</li>
<li><p>3，ShareOG</p>
</li>
<li><p>4，3Delicious</p>
</li>
<li><p>5，Oyonale</p>
</li>
<li><p>6，Telias</p>
</li>
<li><p>7，Cults</p>
</li>
</ul>
